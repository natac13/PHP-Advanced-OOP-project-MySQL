1. User Class:
My initial confusion was on why the 'User' class itself was calling a new
object of itself first before building the user object. I have come now to
understand that when I use the 'Find' functions(find_all, find_by_id) they are
both static functions that I can call without having an instance of the class
itself. This means no wasted memory!! Then those 'find' functions themselves
will then build an 'user' object.
It does this by looping through the attributes of the static version. Then the
record/result from the database will be assigned to the corresponding
attributes.

OG instantiate function:
    // Simple long form approach which I explain more in note.txt
    // $object = new self;
    // $object->id = $record['id'];
    // $object->username = $record['username'];
    // $object->password = $record['password'];
    // $object->first_name = $record['first_name'];
    // $object->last_name = $record['last_name'];

The long form approach meaning that: lets say I had a database with 50 or more
columns that I want to assign to attributes. This would get very tedious very
fast so the proper way to achieve something like this is with a loop.

2. The static method is use as a very quick in and out tool. As well the static
methods need to build the class itself! This is to safe memory and space.

I learned this from Ryan at the php meetup! He also said to just write and
code. Meaning that test as much as possible.

3. Late Static Binding
A problem comes up with self:: in the instantiate method when I try to extend
it from a parent class DatabaseObject. When php sees self:: it binds that to
the original class and not the class that is using the method at runtime.
Therefore what would happen is when the User class goes to run any method
that it inherits which has the word self, the 'self' will refer to the parent
class DatabaseObject instead of User.
    In order to fix the issue so that any method will refer to the class using
it at runtime, I use static instead of self. Also if I need the current class
name I simple use the built in function get_called_class(). To conclude self
gets bound early and static gets bound late or at runtime vs load time.



