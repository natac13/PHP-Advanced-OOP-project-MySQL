1. User Class:
My initial confusion was on why the 'User' class itself was calling a new
object of itself first before building the user object. I have come now to
understand that when I use the 'Find' functions(find_all, find_by_id) they are
both static functions that I can call without having an instance of the class
itself. This means no wasted memory!! Then those 'find' functions themselves
will then build an 'user' object.
It does this by looping through the attributes of the static version. Then the
record/result from the database will be assigned to the corresponding
attributes.

OG instantiate function:
    // Simple long form approach which I explain more in note.txt
    // $object = new self;
    // $object->id = $record['id'];
    // $object->username = $record['username'];
    // $object->password = $record['password'];
    // $object->first_name = $record['first_name'];
    // $object->last_name = $record['last_name'];

The long form approach meaning that: lets say I had a database with 50 or more
columns that I want to assign to attributes. This would get very tedious very
fast so the proper way to achieve something like this is with a loop.

2. The static method is use as a very quick in and out tool. As well the static
methods need to build the class itself! This is to safe memory and space.

I learned this from Ryan at the php meetup! He also said to just write and
code. Meaning that test as much as possible.

3. Late Static Binding
A problem comes up with self:: in the instantiate method when I try to extend
it from a parent class DatabaseObject. When php sees self:: it binds that to
the original class and not the class that is using the method at runtime.
Therefore what would happen is when the User class goes to run any method
that it inherits which has the word self, the 'self' will refer to the parent
class DatabaseObject instead of User.
    In order to fix the issue so that any method will refer to the class using
it at runtime, I use static instead of self. Also if I need the current class
name I simple use the built in function get_called_class(). To conclude self
gets bound early and static gets bound late or at runtime vs load time.

4. Without the trim($entry) != "" I would get an extra line output as a list
item when doing that unordered list of log entries.

5.
The super global _FILES will contain any upoaded files with the post
request meaning they are not part of the $_POST global.

Therefore to get back info about a file that was uploaded I use
$_FILES['(name=? from form)'] in the case with upload.php it is file_upload
The info in the assocative array can be obtained by
'name' for og file name
'type' for mime type("image/gif")
'size' for size in bytes
'tmp_name' for tmp file name on server
'error' for error code
example $_FILES['postName']['tmp_name']

6. When used to create a new User the __construct method will run only making
empty string to the attributes. This does not change the behavior of the code
only improve the use of making a new user in the database. Instead of doing it
the tutorial way which is to make the User object then assign those value to
the instance and then run create. However, I have it so that when you make a
new object it takes parameters and then assigns them to the classes attributes


7. I have learned that the reason I cannot use the password_encrypt() to just
check the password in the database is because that function generates random
salt each time therefore changing the hash for the same word at different times


8. I have got rid of storing the users password in the database since that is
really breaking the 'rules'. Now only the instance has a copy of the plain
text password and the database will only deal with the hashed_password. To
authenticate users now I find only by username since those are unique on
website. Then used the check_password method to hash the input text password
with the same salt as the original. This is done since the first 22 characters
are that salt itself!!




